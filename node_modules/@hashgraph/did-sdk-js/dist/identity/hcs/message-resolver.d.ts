import { Decrypter, Message } from "./message";
import Long from "long";
import { Client, TopicId } from "@hashgraph/sdk";
import { MessageEnvelope } from "./message-envelope";
import { MessageListener } from "./message-listener";
import { Validator } from "../../utils/validator";
export declare abstract class MessageResolver<T extends Message> {
    /**
     * Default time to wait before finishing resolution and after the last message was received.
     */
    static DEFAULT_TIMEOUT: Long;
    protected topicId: TopicId;
    protected results: Map<string, MessageEnvelope<T>>;
    private lastMessageArrivalTime;
    private resultsHandler;
    private errorHandler;
    private decrypter;
    private existingSignatures;
    private listener;
    private noMoreMessagesTimeout;
    /**
     * Instantiates a message resolver.
     *
     * @param topicId Consensus topic ID.
     */
    constructor(topicId: TopicId);
    /**
     * Checks if the message matches preliminary search criteria.
     *
     * @param message The message read from the topic.
     * @return True if the message matches search criteria, false otherwise.
     */
    protected abstract matchesSearchCriteria(message: T): boolean;
    /**
     * Applies custom filters on the message and if successfully verified, adds it to the results map.
     *
     * @param envelope Message inside an envelope in PLAIN mode.
     */
    protected abstract processMessage(envelope: MessageEnvelope<T>): void;
    /**
     * Supplies message listener for messages of specified type.
     *
     * @return The {@link MessageListener} instance.
     */
    protected abstract supplyMessageListener(): MessageListener<T>;
    /**
     * Resolves queries defined in implementing classes against a mirror node.
     *
     * @param client The mirror node client.
     */
    execute(client: Client): void;
    /**
     * Handles incoming DID messages from DID Topic on a mirror node.
     *
     * @param envelope The parsed message envelope in a PLAIN mode.
     */
    private handleMessage;
    /**
     * Waits for a new message from the topic for the configured amount of time.
     */
    protected waitOrFinish(): Promise<void>;
    /**
     * Defines a handler for resolution results.
     * This will be called when the resolution process is finished.
     *
     * @param handler The results handler.
     * @return This resolver instance.
     */
    whenFinished(handler: (input: Map<string, MessageEnvelope<T>>) => void): MessageResolver<T>;
    /**
     * Defines a handler for errors when they happen during resolution.
     *
     * @param handler The error handler.
     * @return This resolver instance.
     */
    onError(handler: (input: Error) => void): MessageResolver<T>;
    /**
     * Defines a maximum time in milliseconds to wait for new messages from the topic.
     * Default is 30 seconds.
     *
     * @param timeout The timeout in milliseconds to wait for new messages from the topic.
     * @return This resolver instance.
     */
    setTimeout(timeout: Long | number): MessageResolver<T>;
    /**
     * Defines decryption function that decrypts submitted the message after consensus was reached.
     * Decryption function must accept a byte array of encrypted message and an Instant that is its consensus timestamp,
     * If decrypter is not specified, encrypted messages will be ignored.
     *
     * @param decrypter The decrypter to use.
     * @return This resolver instance.
     */
    onDecrypt(decrypter: Decrypter<string>): MessageResolver<T>;
    /**
     * Runs validation logic of the resolver's configuration.
     *
     * @param validator The errors validator.
     */
    protected validate(validator: Validator): void;
}
