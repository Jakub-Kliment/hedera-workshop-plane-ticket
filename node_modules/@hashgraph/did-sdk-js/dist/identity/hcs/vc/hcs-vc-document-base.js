"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HcsVcDocumentBase = void 0;
const hashing_1 = require("../../../utils/hashing");
const timestamp_utils_1 = require("../../../utils/timestamp-utils");
const hcs_did_1 = require("../did/hcs-did");
const hcs_vc_document_hash_base_1 = require("./hcs-vc-document-hash-base");
const hcs_vc_document_json_properties_1 = require("./hcs-vc-document-json-properties");
const issuer_1 = require("./issuer");
/**
 * The base for a VC document generation in JSON-LD format.
 * VC documents according to W3C draft specification must be compatible with JSON-LD version 1.1 Up until now there is
 * no Java implementation library of JSON-LD version 1.1. For that reason this object represents only the most basic and
 * mandatory attributes from the VC specification and Hedera HCS DID method specification point of view. Applications
 * shall extend it with any VC document properties or custom properties they require.
 */
class HcsVcDocumentBase extends hcs_vc_document_hash_base_1.HcsVcDocumentHashBase {
    /**
     * Creates a new VC Document instance.
     */
    constructor() {
        super();
        this.context = [hcs_vc_document_json_properties_1.HcsVcDocumentJsonProperties.FIRST_CONTEXT_ENTRY];
    }
    /**
     * Constructs a credential hash that uniquely identifies this verifiable credential.
     * This is not a credential ID, but a hash composed of the properties included in HcsVcDocumentHashBase class
     * (excluding issuer name).
     * Credential hash is used to find the credential on Hedera VC registry.
     * Due to the nature of the VC document the hash taken from the base mandatory fields in this class
     * and shall produce a unique constant.
     * W3C specification defines ID field of a verifiable credential as not mandatory, however Hedera requires issuers to
     * define this property for each VC.
     *
     * @return The credential hash uniquely identifying this verifiable credential.
     */
    toCredentialHash() {
        const map = {};
        map[hcs_vc_document_json_properties_1.HcsVcDocumentJsonProperties.ID] = this.id;
        map[hcs_vc_document_json_properties_1.HcsVcDocumentJsonProperties.TYPE] = this.type;
        map[hcs_vc_document_json_properties_1.HcsVcDocumentJsonProperties.ISSUER] = this.issuer.getId();
        map[hcs_vc_document_json_properties_1.HcsVcDocumentJsonProperties.ISSUANCE_DATE] = timestamp_utils_1.TimestampUtils.toJSON(this.issuanceDate);
        const json = JSON.stringify(map);
        const hash = hashing_1.Hashing.sha256.digest(json);
        return hashing_1.Hashing.base58.encode(hash);
    }
    getContext() {
        return this.context;
    }
    getId() {
        return this.id;
    }
    getType() {
        return this.type;
    }
    getIssuer() {
        return this.issuer;
    }
    getIssuanceDate() {
        return this.issuanceDate;
    }
    getCredentialSubject() {
        return this.credentialSubject;
    }
    setId(id) {
        this.id = id;
    }
    setIssuer(...args) {
        if (typeof args[0] === 'string') {
            this.issuer = new issuer_1.Issuer(args[0]);
            return;
        }
        if (args[0] instanceof issuer_1.Issuer) {
            this.issuer = args[0];
            return;
        }
        if (args[0] instanceof hcs_did_1.HcsDid) {
            this.issuer = new issuer_1.Issuer(args[0].toDid());
            return;
        }
    }
    setIssuanceDate(issuanceDate) {
        this.issuanceDate = issuanceDate;
    }
    /**
     * Adds an additional context to @context field of the VC document.
     *
     * @param context The context to add.
     */
    addContext(context) {
        this.context.push(context);
    }
    /**
     * Adds an additional type to `type` field of the VC document.
     *
     * @param type The type to add.
     */
    addType(type) {
        this.type.push(type);
    }
    /**
     * Adds a credential subject.
     *
     * @param credentialSubject The credential subject to add.
     */
    addCredentialSubject(credentialSubject) {
        if (this.credentialSubject == null) {
            this.credentialSubject = [];
        }
        this.credentialSubject.push(credentialSubject);
    }
    /**
     * Checks if all mandatory fields of a VC document are filled in.
     *
     * @return True if the document is complete and false otherwise.
     */
    isComplete() {
        return ((this.context != null) &&
            (!!this.context.length) &&
            (hcs_vc_document_json_properties_1.HcsVcDocumentJsonProperties.FIRST_CONTEXT_ENTRY == this.context[0]) &&
            (this.type != null) &&
            (!!this.type.length) &&
            (this.type.indexOf(hcs_vc_document_json_properties_1.HcsVcDocumentJsonProperties.VERIFIABLE_CREDENTIAL_TYPE) > -1) &&
            (this.issuanceDate != null) &&
            (this.issuer != null) &&
            (!!this.issuer.getId()) &&
            (this.credentialSubject != null) &&
            (!!this.credentialSubject.length));
    }
    // JsonClass
    toJsonTree() {
        const rootObject = super.toJsonTree();
        const context = [];
        if (this.context) {
            for (let index = 0; index < this.context.length; index++) {
                const element = this.context[index];
                context.push(element);
            }
        }
        rootObject[hcs_vc_document_json_properties_1.HcsVcDocumentJsonProperties.CONTEXT] = context;
        const credentialSubject = [];
        if (this.credentialSubject) {
            for (let index = 0; index < this.credentialSubject.length; index++) {
                const element = this.credentialSubject[index];
                credentialSubject.push(element.toJsonTree());
            }
        }
        rootObject[hcs_vc_document_json_properties_1.HcsVcDocumentJsonProperties.CREDENTIAL_SUBJECT] = credentialSubject;
        return rootObject;
    }
    static fromJsonTree(root, result, credentialSubjectClass) {
        if (!result)
            result = new HcsVcDocumentBase();
        result = hcs_vc_document_hash_base_1.HcsVcDocumentHashBase.fromJsonTree(root, result);
        const jsonCredentialSubject = root[hcs_vc_document_json_properties_1.HcsVcDocumentJsonProperties.CREDENTIAL_SUBJECT];
        const credentialSubject = [];
        for (let i = 0; i < jsonCredentialSubject.length; i++) {
            const item = jsonCredentialSubject[i];
            const subject = credentialSubjectClass.fromJsonTree(item);
            credentialSubject.push(subject);
        }
        result.credentialSubject = credentialSubject;
        return result;
    }
    /**
     * Converts this document into a JSON string.
     *
     * @return The JSON representation of this document.
     */
    toJSON() {
        return JSON.stringify(this.toJsonTree());
    }
    /**
     * Converts a VC document in JSON format into a {@link HcsVcDocumentBase} object.
     * Please note this conversion respects only the fields of the base VC document. All other fields are ignored.
     *
     * @param <U>                    The type of the credential subject.
     * @param json                   The VC document as JSON string.
     * @param credentialSubjectClass The type of the credential subject inside.
     * @return The {@link HcsVcDocumentBase} object.
     */
    static fromJson(json, credentialSubjectClass) {
        let result;
        try {
            const root = JSON.parse(json);
            result = this.fromJsonTree(root, null, credentialSubjectClass);
        }
        catch (e) {
            throw new Error('Given JSON string is not a valid HcsVcDocumentBase ' + e.message);
        }
        return result;
    }
}
exports.HcsVcDocumentBase = HcsVcDocumentBase;
