"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HcsVcTopicListener = void 0;
const message_envelope_1 = require("../message-envelope");
const message_listener_1 = require("../message-listener");
const hcs_vc_message_1 = require("./hcs-vc-message");
/**
 * A listener of confirmed {@link HcsVcMessage} messages from a VC topic.
 * Messages are received from a given mirror node, parsed and validated.
 */
class HcsVcTopicListener extends message_listener_1.MessageListener {
    constructor(...args) {
        const vcTopicId = args[0];
        super(vcTopicId);
        if (args[1]) {
            this.publicKeysProvider = args[1];
        }
        else {
            this.publicKeysProvider = null;
        }
    }
    extractMessage(response) {
        let result = null;
        try {
            result = message_envelope_1.MessageEnvelope.fromMirrorResponse(response, hcs_vc_message_1.HcsVcMessage);
        }
        catch (err) {
            this.handleError(err);
        }
        return result;
    }
    isMessageValid(envelope, response) {
        try {
            const msgDecrypter = !!this.decrypter ? hcs_vc_message_1.HcsVcMessage.getDecrypter(this.decrypter) : null;
            const message = envelope.open(msgDecrypter);
            if (message == null) {
                this.reportInvalidMessage(response, "Empty message received when opening envelope");
                return false;
            }
            if (!message.isValid()) {
                this.reportInvalidMessage(response, "Message content validation failed.");
                return false;
            }
            // Validate signature only if public key provider has been supplied.
            if (!!this.publicKeysProvider && !this.isSignatureAccepted(envelope)) {
                this.reportInvalidMessage(response, "Signature validation failed");
                return false;
            }
            return true;
        }
        catch (err) {
            this.handleError(err);
            this.reportInvalidMessage(response, "Exception while validating message: " + err.message);
            return false;
        }
    }
    /**
     * Checks if the signature on the envelope is accepted by any public key supplied for the credential hash.
     *
     * @param envelope The message envelope.
     * @return True if signature is accepted, false otherwise.
     */
    isSignatureAccepted(envelope) {
        if (!this.publicKeysProvider) {
            return false;
        }
        const message = envelope.open();
        const acceptedKeys = this.publicKeysProvider(message.getCredentialHash());
        if (!acceptedKeys || !acceptedKeys.length) {
            return false;
        }
        for (let publicKey of acceptedKeys) {
            if (envelope.isSignatureValid(publicKey)) {
                return true;
            }
        }
        return false;
    }
}
exports.HcsVcTopicListener = HcsVcTopicListener;
