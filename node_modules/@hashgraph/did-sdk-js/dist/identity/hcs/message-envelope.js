"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageEnvelope = void 0;
const long_1 = __importDefault(require("long"));
const message_mode_1 = require("./message-mode");
const serializable_mirror_consensus_response_1 = require("./serializable-mirror-consensus-response");
const js_base64_1 = require("js-base64");
const arrays_utils_1 = require("../../utils/arrays-utils");
/**
 * The envelope for Hedera identity messages sent to HCS DID or VC topics.
 */
class MessageEnvelope {
    constructor(...args) {
        if (args.length === 0) {
            // do nothing
        }
        else if (args.length === 1) {
            const [message] = args;
            this.message = message;
            this.mode = message_mode_1.MessageMode.PLAIN;
        }
        else {
            throw new Error('Wrong arguments passed to constructor');
        }
    }
    get messageJson() {
        if (!this.message) {
            return null;
        }
        return this.message.toJSON();
    }
    ;
    /**
     * Signs this message envelope with the given signing function.
     *
     * @param signer The signing function.
     * @return This envelope signed and serialized to JSON, ready for submission to HCS topic.
     */
    sign(signer) {
        if (!signer) {
            throw new Error('Signing function is not provided.');
        }
        if (this.signature) {
            throw new Error('Message is already signed.');
        }
        const msgBytes = arrays_utils_1.ArraysUtils.fromString(this.message.toJSON());
        const signatureBytes = signer(msgBytes);
        this.signature = js_base64_1.Base64.fromUint8Array(signatureBytes);
        return arrays_utils_1.ArraysUtils.fromString(this.toJSON());
    }
    toJsonTree() {
        const result = {};
        result.mode = this.mode;
        if (this.message) {
            result[MessageEnvelope.MESSAGE_KEY] = this.message.toJsonTree();
        }
        if (this.signature) {
            result[MessageEnvelope.SIGNATURE_KEY] = this.signature;
        }
        return result;
    }
    /**
     * Converts this message envelope into a JSON string.
     *
     * @return The JSON string representing this message envelope.
     */
    toJSON() {
        return JSON.stringify(this.toJsonTree());
    }
    /**
     * Converts a message from a DID or VC topic response into object instance.
     *
     * @param <U>          Type of the message inside envelope.
     * @param response     Topic message as a response from mirror node.
     * @param messageClass Class type of the message inside envelope.
     * @return The {@link MessageEnvelope}.
     */
    static fromMirrorResponse(response, messageClass) {
        const msgJson = arrays_utils_1.ArraysUtils.toString(response.contents);
        const result = MessageEnvelope.fromJson(msgJson, messageClass);
        result.mirrorResponse = new serializable_mirror_consensus_response_1.SerializableMirrorConsensusResponse(response);
        return result;
    }
    /**
     * Converts a VC topic message from a JSON string into object instance.
     *
     * @param <U>          Type of the message inside envelope.
     * @param json         VC topic message as JSON string.
     * @param messageClass Class of the message inside envelope.
     * @return The {@link MessageEnvelope}.
     */
    static fromJson(json, messageClass) {
        const result = new MessageEnvelope();
        const root = JSON.parse(json);
        result.mode = root.mode;
        result.signature = root[MessageEnvelope.SIGNATURE_KEY];
        if (root.hasOwnProperty(MessageEnvelope.MESSAGE_KEY)) {
            result.message = messageClass.fromJsonTree(root[MessageEnvelope.MESSAGE_KEY]);
        }
        else {
            result.message = null;
        }
        return result;
    }
    /**
     * Encrypts the message in this envelope and returns its encrypted instance.
     *
     * @param encrypter The function used to encrypt the message.
     * @return This envelope instance.
     */
    encrypt(encrypter) {
        if (!encrypter) {
            throw new Error('The encryption function is not provided.');
        }
        this.decryptedMessage = this.message;
        this.message = encrypter(this.message);
        this.mode = message_mode_1.MessageMode.ENCRYPTED;
        return this;
    }
    isSignatureValid(...args) {
        if (!this.signature || !this.message) {
            return false;
        }
        let publicKey;
        if (typeof args[0] == "function") {
            const publicKeyProvider = args[0];
            publicKey = publicKeyProvider(this);
        }
        else {
            publicKey = args[0];
        }
        if (!publicKey) {
            return false;
        }
        const signatureToVerify = js_base64_1.Base64.toUint8Array(this.signature);
        const messageBytes = arrays_utils_1.ArraysUtils.fromString(this.message.toJSON());
        return publicKey.verify(messageBytes, signatureToVerify);
    }
    /**
     * Opens a message in this envelope.
     * If the message is encrypted, the given decrypter will be used first to decrypt it.
     * If the message is not encrypted, it will be immediately returned.
     *
     * @param decrypter The function used to decrypt the message.
     * @return The message object in a plain mode.
     */
    open(decrypter = null) {
        if (this.decryptedMessage != null) {
            return this.decryptedMessage;
        }
        if (message_mode_1.MessageMode.ENCRYPTED !== this.mode) {
            this.decryptedMessage = this.message;
        }
        else if (!decrypter) {
            throw new Error("The message is encrypted, provide decryption function.");
        }
        else if (!this.decryptedMessage) {
            this.decryptedMessage = decrypter(this.message, this.getConsensusTimestamp());
        }
        return this.decryptedMessage;
    }
    getSignature() {
        return this.signature;
    }
    getConsensusTimestamp() {
        return (!this.mirrorResponse) ? null : this.mirrorResponse.consensusTimestamp;
    }
    getMode() {
        return this.mode;
    }
    getMirrorResponse() {
        return this.mirrorResponse;
    }
}
exports.MessageEnvelope = MessageEnvelope;
MessageEnvelope.MESSAGE_KEY = 'message';
MessageEnvelope.SIGNATURE_KEY = 'signature';
MessageEnvelope.serialVersionUID = long_1.default.fromInt(1);
