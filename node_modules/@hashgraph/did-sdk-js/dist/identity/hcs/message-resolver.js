"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageResolver = void 0;
const long_1 = __importDefault(require("long"));
const sdk_1 = require("@hashgraph/sdk");
const validator_1 = require("../../utils/validator");
const sleep_1 = require("../../utils/sleep");
class MessageResolver {
    /**
     * Instantiates a message resolver.
     *
     * @param topicId Consensus topic ID.
     */
    constructor(topicId) {
        this.topicId = topicId;
        this.results = new Map();
        this.noMoreMessagesTimeout = MessageResolver.DEFAULT_TIMEOUT;
        this.lastMessageArrivalTime = long_1.default.fromInt(Date.now());
    }
    /**
     * Resolves queries defined in implementing classes against a mirror node.
     *
     * @param client The mirror node client.
     */
    execute(client) {
        new validator_1.Validator().checkValidationErrors('Resolver not executed: ', v => {
            return this.validate(v);
        });
        this.existingSignatures = [];
        this.listener = this.supplyMessageListener();
        this.listener.setStartTime(new sdk_1.Timestamp(0, 0))
            .setEndTime(sdk_1.Timestamp.fromDate(new Date()))
            .setIgnoreErrors(false)
            .onError(this.errorHandler)
            .onDecrypt(this.decrypter)
            .subscribe(client, msg => {
            return this.handleMessage(msg);
        });
        this.lastMessageArrivalTime = long_1.default.fromInt(Date.now());
        this.waitOrFinish();
    }
    /**
     * Handles incoming DID messages from DID Topic on a mirror node.
     *
     * @param envelope The parsed message envelope in a PLAIN mode.
     */
    handleMessage(envelope) {
        this.lastMessageArrivalTime = long_1.default.fromInt(Date.now());
        if (!this.matchesSearchCriteria(envelope.open())) {
            return;
        }
        if (this.existingSignatures.indexOf(envelope.getSignature()) != -1) {
            return;
        }
        this.existingSignatures.push(envelope.getSignature());
        this.processMessage(envelope);
    }
    /**
     * Waits for a new message from the topic for the configured amount of time.
     */
    waitOrFinish() {
        return __awaiter(this, void 0, void 0, function* () {
            const timeDiff = long_1.default.fromInt(Date.now()).sub(this.lastMessageArrivalTime);
            if (timeDiff.lt(this.noMoreMessagesTimeout)) {
                yield (0, sleep_1.Sleep)(this.noMoreMessagesTimeout.sub(timeDiff).toNumber());
                yield this.waitOrFinish();
                return;
            }
            this.resultsHandler(this.results);
            if (this.listener) {
                this.listener.unsubscribe();
            }
        });
    }
    /**
     * Defines a handler for resolution results.
     * This will be called when the resolution process is finished.
     *
     * @param handler The results handler.
     * @return This resolver instance.
     */
    whenFinished(handler) {
        this.resultsHandler = handler;
        return this;
    }
    /**
     * Defines a handler for errors when they happen during resolution.
     *
     * @param handler The error handler.
     * @return This resolver instance.
     */
    onError(handler) {
        this.errorHandler = handler;
        return this;
    }
    /**
     * Defines a maximum time in milliseconds to wait for new messages from the topic.
     * Default is 30 seconds.
     *
     * @param timeout The timeout in milliseconds to wait for new messages from the topic.
     * @return This resolver instance.
     */
    setTimeout(timeout) {
        this.noMoreMessagesTimeout = long_1.default.fromValue(timeout);
        return this;
    }
    /**
     * Defines decryption function that decrypts submitted the message after consensus was reached.
     * Decryption function must accept a byte array of encrypted message and an Instant that is its consensus timestamp,
     * If decrypter is not specified, encrypted messages will be ignored.
     *
     * @param decrypter The decrypter to use.
     * @return This resolver instance.
     */
    onDecrypt(decrypter) {
        this.decrypter = decrypter;
        return this;
    }
    /**
     * Runs validation logic of the resolver's configuration.
     *
     * @param validator The errors validator.
     */
    validate(validator) {
        validator.require(this.results.size > 0, 'Nothing to resolve.');
        validator.require(!!this.topicId, 'Consensus topic ID not defined.');
        validator.require(!!this.resultsHandler, 'Results handler \'whenFinished\' not defined.');
    }
}
exports.MessageResolver = MessageResolver;
/**
 * Default time to wait before finishing resolution and after the last message was received.
 */
MessageResolver.DEFAULT_TIMEOUT = long_1.default.fromInt(30000);
