"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HcsDidMessage = void 0;
const sdk_1 = require("@hashgraph/sdk");
const hashing_1 = require("../../../utils/hashing");
const timestamp_utils_1 = require("../../../utils/timestamp-utils");
const did_document_base_1 = require("../../did-document-base");
const did_document_json_properties_1 = require("../../did-document-json-properties");
const message_1 = require("../message");
const message_envelope_1 = require("../message-envelope");
const hcs_did_1 = require("./hcs-did");
/**
 * The DID document message submitted to appnet's DID Topic.
 */
class HcsDidMessage extends message_1.Message {
    /**
     * Creates a new instance of {@link HcsDidMessage}.
     *
     * @param operation         The operation on DID document.
     * @param did               The DID string.
     * @param didDocumentBase64 The Base64-encoded DID document.
     */
    constructor(operation, did, didDocumentBase64) {
        super();
        this.operation = operation;
        this.did = did;
        this.didDocumentBase64 = didDocumentBase64;
    }
    getOperation() {
        return this.operation;
    }
    getDid() {
        return this.did;
    }
    getDidDocumentBase64() {
        return this.didDocumentBase64;
    }
    getCreated() {
        return this.created;
    }
    getUpdated() {
        return this.updated;
    }
    setUpdated(updated) {
        this.updated = updated;
    }
    setCreated(created) {
        this.created = created;
    }
    /**
     * Decodes didDocumentBase64 field and returns its content.
     * In case this message is in encrypted mode, it will return encrypted content,
     * so getPlainDidDocument method should be used instead.
     * If message consensus timestamps for creation and update are provided they will be injected into the result
     * document upon decoding.
     *
     * @return The decoded DID document as JSON string.
     */
    getDidDocument() {
        if (this.didDocumentBase64 == null) {
            return null;
        }
        let document = hashing_1.Hashing.base64.decode(this.didDocumentBase64);
        // inject timestamps
        if (this.created != null || this.updated != null) {
            const root = JSON.parse(document);
            if (this.created != null) {
                root[did_document_json_properties_1.DidDocumentJsonProperties.CREATED] = timestamp_utils_1.TimestampUtils.toJSON(this.created);
            }
            if (this.updated != null) {
                root[did_document_json_properties_1.DidDocumentJsonProperties.UPDATED] = timestamp_utils_1.TimestampUtils.toJSON(this.updated);
            }
            document = JSON.stringify(root);
        }
        return document;
    }
    isValid(...args) {
        const didTopicId = args[0] || null;
        if (this.did == null || this.didDocumentBase64 == null) {
            return false;
        }
        try {
            const doc = did_document_base_1.DidDocumentBase.fromJson(this.getDidDocument());
            // Validate if DID and DID document are present and match
            if (this.did != doc.getId()) {
                return false;
            }
            // Validate if DID root key is present in the document
            if (doc.getDidRootKey() == null || doc.getDidRootKey().getPublicKeyBase58() == null) {
                return false;
            }
            // Verify that DID was derived from this DID root key
            const hcsDid = hcs_did_1.HcsDid.fromString(this.did);
            // Extract public key from the DID document
            const publicKeyBytes = hashing_1.Hashing.base58.decode(doc.getDidRootKey().getPublicKeyBase58());
            const publicKey = sdk_1.PublicKey.fromBytes(publicKeyBytes);
            if (hcs_did_1.HcsDid.publicKeyToIdString(publicKey) != hcsDid.getIdString()) {
                return false;
            }
            // Verify that the message was sent to the right topic, if the DID contains the topic
            if (!!didTopicId && !!hcsDid.getDidTopicId() && (didTopicId.toString() != hcsDid.getDidTopicId().toString())) {
                return false;
            }
        }
        catch (e) {
            return false;
        }
        return true;
    }
    /**
     * Extracts #did-root-key from the DID document.
     *
     * @return Public key of the DID subject.
     */
    extractDidRootKey() {
        let result = null;
        try {
            const doc = did_document_base_1.DidDocumentBase.fromJson(this.getDidDocument());
            // Make sure that DID root key is present in the document
            if (doc.getDidRootKey() != null && doc.getDidRootKey().getPublicKeyBase58() != null) {
                const publicKeyBytes = hashing_1.Hashing.base58.decode(doc.getDidRootKey().getPublicKeyBase58());
                result = sdk_1.PublicKey.fromBytes(publicKeyBytes);
            }
            // ArrayIndexOutOfBoundsException is thrown in case public key is invalid in PublicKey.fromBytes
        }
        catch (e) {
            return null;
        }
        return result;
    }
    toJsonTree() {
        const result = super.toJsonTree();
        result.operation = this.operation;
        result.did = this.did;
        result.didDocumentBase64 = this.didDocumentBase64;
        return result;
    }
    static fromJsonTree(tree, result) {
        if (!result) {
            result = new HcsDidMessage(tree.operation, tree.did, tree.didDocumentBase64);
        }
        else {
            result.operation = tree.operation;
            result.did = tree.did;
            result.didDocumentBase64 = tree.didDocumentBase64;
        }
        result = super.fromJsonTree(tree, result);
        return result;
    }
    toJSON() {
        return JSON.stringify(this.toJsonTree());
    }
    static fromJson(json) {
        return message_1.Message.fromJsonTree(JSON.parse(json));
    }
    /**
     * Creates a new DID message for submission to HCS topic.
     *
     * @param didDocumentJson DID document as JSON string.
     * @param operation       The operation on DID document.
     * @return The HCS message wrapped in an envelope for the given DID document and method operation.
     */
    static fromDidDocumentJson(didDocumentJson, operation) {
        const didDocumentBase = did_document_base_1.DidDocumentBase.fromJson(didDocumentJson);
        const didDocumentBase64 = hashing_1.Hashing.base64.encode(didDocumentJson);
        const message = new HcsDidMessage(operation, didDocumentBase.getId(), didDocumentBase64);
        return new message_envelope_1.MessageEnvelope(message);
    }
    /**
     * Provides an encryption operator that converts an {@link HcsDidMessage} into encrypted one.
     *
     * @param encryptionFunction The encryption function to use for encryption of single attributes.
     * @return The encryption operator instance.
     */
    static getEncrypter(encryptionFunction) {
        if (encryptionFunction == null) {
            throw "Encryption function is missing or null.";
        }
        return function (message) {
            const operation = message.getOperation();
            // Encrypt the DID
            const encryptedDid = encryptionFunction(message.getDid());
            const did = hashing_1.Hashing.base64.encode(encryptedDid);
            // Encrypt the DID document
            const encryptedDoc = encryptionFunction(message.getDidDocumentBase64());
            const didDocumentBase64 = hashing_1.Hashing.base64.encode(encryptedDoc);
            return new HcsDidMessage(operation, did, didDocumentBase64);
        };
    }
    /**
     * Provides a decryption function that converts {@link HcsDidMessage} in encrypted for into a plain form.
     *
     * @param decryptionFunction The decryption function to use for decryption of single attributes.
     * @return The Decryption function for the {@link HcsDidMessage}
     */
    static getDecrypter(decryptionFunction) {
        if (decryptionFunction == null) {
            throw "Decryption function is missing or null.";
        }
        return function (encryptedMsg, consensusTimestamp) {
            const operation = encryptedMsg.getOperation();
            // Decrypt DID string
            let decryptedDid = encryptedMsg.getDid();
            if (decryptedDid != null) {
                const did = hashing_1.Hashing.base64.decode(decryptedDid);
                decryptedDid = decryptionFunction(did, consensusTimestamp);
            }
            // Decrypt DID document
            let decryptedDocBase64 = encryptedMsg.getDidDocumentBase64();
            if (decryptedDocBase64 != null) {
                const doc = hashing_1.Hashing.base64.decode(decryptedDocBase64);
                decryptedDocBase64 = decryptionFunction(doc, consensusTimestamp);
            }
            return new HcsDidMessage(operation, decryptedDid, decryptedDocBase64);
        };
    }
}
exports.HcsDidMessage = HcsDidMessage;
