"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HcsDid = void 0;
const did_syntax_1 = require("../../did-syntax");
const sdk_1 = require("@hashgraph/sdk");
const hashing_1 = require("../../../utils/hashing");
const did_document_base_1 = require("../../did-document-base");
const hcs_did_root_key_1 = require("./hcs-did-root-key");
/**
 * Hedera Decentralized Identifier for Hedera DID Method specification based on HCS.
 */
class HcsDid {
    constructor(...args) {
        if ((typeof args[0] === 'string') &&
            (args[1] instanceof sdk_1.PublicKey) &&
            (args[2] instanceof sdk_1.FileId) &&
            ((args[4] instanceof sdk_1.TopicId) || args[4] === undefined) &&
            (args.length === 4)) {
            const [network, didRootKey, addressBookFileId, didTopicId] = args;
            this.didTopicId = didTopicId;
            this.addressBookFileId = addressBookFileId;
            this.network = network;
            this.didRootKey = didRootKey;
            this.idString = HcsDid.publicKeyToIdString(didRootKey);
            this.did = this.buildDid();
            return;
        }
        if ((typeof args[0] === 'string') &&
            (args[1] instanceof sdk_1.PrivateKey) &&
            (args[2] instanceof sdk_1.FileId) &&
            ((args[4] instanceof sdk_1.TopicId) || args[4] === undefined) &&
            (args.length === 4)) {
            const [network, privateDidRootKey, addressBookFileId, didTopicId] = args;
            this.didTopicId = didTopicId;
            this.addressBookFileId = addressBookFileId;
            this.network = network;
            this.didRootKey = privateDidRootKey.publicKey;
            this.idString = HcsDid.publicKeyToIdString(privateDidRootKey.publicKey);
            this.did = this.buildDid();
            this.privateDidRootKey = privateDidRootKey;
            return;
        }
        if ((typeof args[0] === 'string') &&
            (args[1] instanceof sdk_1.PublicKey) &&
            (args[2] instanceof sdk_1.FileId) &&
            (args.length === 3)) {
            const [network, didRootKey, addressBookFileId] = args;
            this.didTopicId = null;
            this.addressBookFileId = addressBookFileId;
            this.network = network;
            this.didRootKey = didRootKey;
            this.idString = HcsDid.publicKeyToIdString(didRootKey);
            this.did = this.buildDid();
            return;
        }
        if ((typeof args[0] === 'string') &&
            (typeof args[1] === 'string') &&
            (args[2] instanceof sdk_1.FileId) &&
            ((args[4] instanceof sdk_1.TopicId) || args[4] === undefined) &&
            (args.length === 4)) {
            const [network, idString, addressBookFileId, didTopicId] = args;
            this.didTopicId = didTopicId;
            this.addressBookFileId = addressBookFileId;
            this.network = network;
            this.idString = idString;
            this.did = this.buildDid();
            return;
        }
        throw new Error('Couldn\'t find constructor');
    }
    /**
     * Converts a Hedera DID string into {@link HcsDid} object.
     *
     * @param didString A Hedera DID string.
     * @return {@link HcsDid} object derived from the given Hedera DID string.
     */
    static fromString(didString) {
        if (!didString) {
            throw new Error("DID string cannot be null");
        }
        const mainParts = didString.split(did_syntax_1.DidSyntax.DID_PARAMETER_SEPARATOR);
        let topicId, addressBookFileId;
        const didParts = mainParts.shift().split(did_syntax_1.DidSyntax.DID_METHOD_SEPARATOR);
        if (didParts.shift() !== did_syntax_1.DidSyntax.DID_PREFIX) {
            throw new Error('DID string is invalid: invalid prefix.');
        }
        const methodName = didParts.shift();
        if (did_syntax_1.DidSyntax.Method.HEDERA_HCS !== methodName) {
            throw new Error('DID string is invalid: invalid method name: ' + methodName);
        }
        try {
            const networkName = didParts.shift();
            const params = this.extractParameters(mainParts, methodName, networkName);
            addressBookFileId = sdk_1.FileId.fromString(params.get(did_syntax_1.DidSyntax.MethodSpecificParameter.ADDRESS_BOOK_FILE_ID));
            if (params.has(did_syntax_1.DidSyntax.MethodSpecificParameter.DID_TOPIC_ID)) {
                topicId = sdk_1.TopicId.fromString(params.get(did_syntax_1.DidSyntax.MethodSpecificParameter.DID_TOPIC_ID));
            }
            const didIdString = didParts.shift();
            if (didIdString.length < 32 || didParts.shift()) {
                throw new Error('DID string is invalid.');
            }
            return new HcsDid(networkName, didIdString, addressBookFileId, topicId);
        }
        catch (e) {
            throw new Error('DID string is invalid. ' + e.message);
        }
    }
    /**
     * Extracts method-specific URL parameters.
     *
     * @param mainParts   Iterator over main parts of the DID.
     * @param methodName  The method name.
     * @param networkName The network name.
     * @return A map of method-specific URL parameters and their values.
     */
    static extractParameters(mainParts, methodName, networkName) {
        const result = new Map();
        const fidParamName = [methodName, networkName, did_syntax_1.DidSyntax.MethodSpecificParameter.ADDRESS_BOOK_FILE_ID].join(did_syntax_1.DidSyntax.DID_METHOD_SEPARATOR);
        const tidParamName = [methodName, networkName, did_syntax_1.DidSyntax.MethodSpecificParameter.DID_TOPIC_ID].join(did_syntax_1.DidSyntax.DID_METHOD_SEPARATOR);
        let mp;
        while (mp = mainParts.shift()) {
            const paramValue = mp.split(did_syntax_1.DidSyntax.DID_PARAMETER_VALUE_SEPARATOR);
            if (paramValue.length != this.DID_PARAMETER_VALUE_PARTS) {
                continue;
            }
            else if (fidParamName === paramValue[0]) {
                result.set(did_syntax_1.DidSyntax.MethodSpecificParameter.ADDRESS_BOOK_FILE_ID, paramValue[1]);
            }
            else if (tidParamName === paramValue[0]) {
                result.set(did_syntax_1.DidSyntax.MethodSpecificParameter.DID_TOPIC_ID, paramValue[1]);
            }
        }
        if (!result.has(did_syntax_1.DidSyntax.MethodSpecificParameter.ADDRESS_BOOK_FILE_ID)) {
            throw new Error('DID string is invalid. Required method-specific URL parameter not found: ' + did_syntax_1.DidSyntax.MethodSpecificParameter.ADDRESS_BOOK_FILE_ID);
        }
        return result;
    }
    /**
     * Generates a random DID root key.
     *
     * @return A private key of generated public DID root key.
     */
    static generateDidRootKey() {
        return sdk_1.PrivateKey.generate();
    }
    /**
     * Generates DID document base from the given DID and its root key.
     *
     * @param didRootKey Public key used to build this DID.
     * @return The DID document base.
     * @throws IllegalArgumentException In case given DID root key does not match this DID.
     */
    generateDidDocument() {
        const result = new did_document_base_1.DidDocumentBase(this.toDid());
        if (this.didRootKey) {
            const rootKey = hcs_did_root_key_1.HcsDidRootKey.fromHcsIdentity(this, this.didRootKey);
            result.setDidRootKey(rootKey);
        }
        return result;
    }
    getNetwork() {
        return this.network;
    }
    getMethod() {
        return did_syntax_1.DidSyntax.Method.HEDERA_HCS;
    }
    toString() {
        return this.did;
    }
    getDidTopicId() {
        return this.didTopicId;
    }
    getAddressBookFileId() {
        return this.addressBookFileId;
    }
    getIdString() {
        return this.idString;
    }
    toDid() {
        return this.did;
    }
    /**
     * Constructs DID string from the instance of DID object.
     *
     * @return A DID string.
     */
    buildDid() {
        const methodNetwork = [this.getMethod().toString(), this.network].join(did_syntax_1.DidSyntax.DID_METHOD_SEPARATOR);
        let ret;
        ret = did_syntax_1.DidSyntax.DID_PREFIX +
            did_syntax_1.DidSyntax.DID_METHOD_SEPARATOR +
            methodNetwork +
            did_syntax_1.DidSyntax.DID_METHOD_SEPARATOR +
            this.idString +
            did_syntax_1.DidSyntax.DID_PARAMETER_SEPARATOR +
            methodNetwork +
            did_syntax_1.DidSyntax.DID_METHOD_SEPARATOR +
            did_syntax_1.DidSyntax.MethodSpecificParameter.ADDRESS_BOOK_FILE_ID +
            did_syntax_1.DidSyntax.DID_PARAMETER_VALUE_SEPARATOR +
            this.addressBookFileId.toString();
        if (this.didTopicId) {
            ret = ret +
                did_syntax_1.DidSyntax.DID_PARAMETER_SEPARATOR +
                methodNetwork +
                did_syntax_1.DidSyntax.DID_METHOD_SEPARATOR +
                did_syntax_1.DidSyntax.MethodSpecificParameter.DID_TOPIC_ID +
                did_syntax_1.DidSyntax.DID_PARAMETER_VALUE_SEPARATOR +
                this.didTopicId.toString();
        }
        return ret;
    }
    /**
     * Constructs an id-string of a DID from a given public key.
     *
     * @param didRootKey Public Key from which the DID is created.
     * @return The id-string of a DID that is a Base58-encoded SHA-256 hash of a given public key.
     */
    static publicKeyToIdString(didRootKey) {
        return hashing_1.Hashing.base58.encode(hashing_1.Hashing.sha256.digest(didRootKey.toBytes()));
    }
    /**
     * Returns a private key of DID root key.
     * This is only available if it was provided during {@link HcsDid} construction.
     *
     * @return The private key of DID root key.
     */
    getPrivateDidRootKey() {
        return this.privateDidRootKey;
    }
    /**
     * Returns a public key of DID root key.
     * This is only available if it was provided during {@link HcsDid} construction.
     *
     * @return The private key of DID root key.
     */
    getPublicDidRootKey() {
        return this.didRootKey;
    }
}
exports.HcsDid = HcsDid;
HcsDid.DID_METHOD = did_syntax_1.DidSyntax.Method.HEDERA_HCS;
HcsDid.DID_PARAMETER_VALUE_PARTS = 2;
