"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageListener = void 0;
const sdk_1 = require("@hashgraph/sdk");
const message_mode_1 = require("./message-mode");
/**
 * A listener of confirmed messages from a HCS identity topic.
 * Messages are received from a given mirror node, parsed and validated.
 */
class MessageListener {
    /**
     * Creates a new instance of a topic listener for the given consensus topic.
     * By default, invalid messages are ignored and errors are not.
     *
     * @param topicId The consensus topic ID.
     */
    constructor(topicId) {
        this.topicId = topicId;
        this.query = new sdk_1.TopicMessageQuery().setTopicId(topicId);
        this.ignoreErrors = false;
    }
    /**
     * Adds a custom filter for topic responses from a mirror node.
     * Messages that do not pass the test are skipped before any other checks are run.
     *
     * @param filter The filter function.
     * @return This listener instance.
     */
    addFilter(filter) {
        if (!this.filters) {
            this.filters = [];
        }
        this.filters.push(filter);
        return this;
    }
    /**
     * Subscribes to mirror node topic messages stream.
     *
     * @param client   Mirror client instance.
     * @param receiver Receiver of parsed messages.
     * @return This listener instance.
     */
    subscribe(client, receiver) {
        const errorHandler = (message, error) => {
            this.handleError(error);
        };
        const listener = (message) => {
            this.handleResponse(message, receiver);
        };
        this.subscriptionHandle = this.query.subscribe(client, errorHandler, listener);
        return this;
    }
    /**
     * Stops receiving messages from the topic.
     */
    unsubscribe() {
        if (this.subscriptionHandle) {
            this.subscriptionHandle.unsubscribe();
        }
    }
    /**
     * Handles incoming messages from the topic on a mirror node.
     *
     * @param response Response message coming from the mirror node for the topic.
     * @param receiver Consumer of the result message.
     */
    handleResponse(response, receiver) {
        if (this.filters) {
            for (let filter of this.filters) {
                if (!filter(response)) {
                    this.reportInvalidMessage(response, "Message was rejected by external filter");
                    return;
                }
            }
        }
        const envelope = this.extractMessage(response);
        if (!envelope) {
            this.reportInvalidMessage(response, "Extracting envelope from the mirror response failed");
            return;
        }
        if ((message_mode_1.MessageMode.ENCRYPTED === envelope.getMode()) && !this.decrypter) {
            this.reportInvalidMessage(response, "Message is encrypted and no decryption function was provided");
            return;
        }
        if (this.isMessageValid(envelope, response)) {
            receiver(envelope);
        }
    }
    /**
     * Handles the given error internally.
     * If external error handler is defined, passes the error there, otherwise raises RuntimeException or ignores it
     * depending on a ignoreErrors flag.
     *
     * @param err The error.
     * @throws RuntimeException Runtime exception with the given error in case external error handler is not defined
     *                          and errors were not requested to be ignored.
     */
    handleError(err) {
        if (this.errorHandler) {
            this.errorHandler(err);
        }
        else if (!this.ignoreErrors) {
            throw new Error(err.message);
        }
    }
    /**
     * Reports invalid message to the handler.
     *
     * @param response The mirror response.
     * @param reason   The reason why message validation failed.
     */
    reportInvalidMessage(response, reason) {
        if (this.invalidMessageHandler) {
            this.invalidMessageHandler(response, reason);
        }
    }
    /**
     * Defines a handler for errors when they happen during execution.
     *
     * @param handler The error handler.
     * @return This transaction instance.
     */
    onError(handler) {
        this.errorHandler = handler;
        return this;
    }
    /**
     * Defines a handler for invalid messages received from the topic.
     * The first parameter of the handler is the mirror response.
     * The second parameter is the reason why the message failed validation (if available).
     *
     * @param handler The invalid message handler.
     * @return This transaction instance.
     */
    onInvalidMessageReceived(handler) {
        this.invalidMessageHandler = handler;
        return this;
    }
    /**
     * Defines decryption function that decrypts submitted message attributes after consensus is reached.
     * Decryption function must accept a byte array of encrypted message and an Timestamp that is its consensus timestamp,
     * If decrypter is not specified, encrypted messages will be ignored.
     *
     * @param decrypter The decryption function to use.
     * @return This transaction instance.
     */
    onDecrypt(decrypter) {
        this.decrypter = decrypter;
        return this;
    }
    setStartTime(startTime) {
        this.query.setStartTime(startTime);
        return this;
    }
    setEndTime(endTime) {
        this.query.setEndTime(endTime);
        return this;
    }
    setLimit(messagesLimit) {
        this.query.setLimit(messagesLimit);
        return this;
    }
    setIgnoreErrors(ignoreErrors) {
        this.ignoreErrors = ignoreErrors;
        return this;
    }
}
exports.MessageListener = MessageListener;
