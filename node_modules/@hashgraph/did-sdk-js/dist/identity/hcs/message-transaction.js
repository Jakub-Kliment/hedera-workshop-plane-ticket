"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageTransaction = void 0;
const sdk_1 = require("@hashgraph/sdk");
const validator_1 = require("../../utils/validator");
const moment_1 = __importDefault(require("moment"));
const arrays_utils_1 = require("../../utils/arrays-utils");
class MessageTransaction {
    constructor(...args) {
        if (args.length === 1) {
            const [topicId] = args;
            this.topicId = topicId;
            this.executed = false;
        }
        else if (args.length === 2) {
            const [topicId, message] = args;
            this.topicId = topicId;
            this.message = message;
            this.executed = false;
        }
        else {
            throw new Error('Invalid arguments');
        }
    }
    /**
     * Handles the error.
     * If external error handler is defined, passes the error there, otherwise raises RuntimeException.
     *
     * @param err The error.
     * @throws RuntimeException Runtime exception with the given error in case external error handler is not defined.
     */
    handleError(err) {
        if (this.errorHandler) {
            this.errorHandler(err);
        }
        else {
            throw new Error(err.message);
        }
    }
    /**
     * Defines encryption function that encrypts the message attributes before submission.
     *
     * @param encrypter The encrypter to use.
     * @return This transaction instance.
     */
    onEncrypt(encrypter) {
        this.encrypter = encrypter;
        return this;
    }
    /**
     * Handles event from a mirror node when a message was consensus was reached and message received.
     *
     * @param receiver The receiver handling incoming message.
     * @return This transaction instance.
     */
    onMessageConfirmed(receiver) {
        this.receiver = receiver;
        return this;
    }
    /**
     * Defines a handler for errors when they happen during execution.
     *
     * @param handler The error handler.
     * @return This transaction instance.
     */
    onError(handler) {
        this.errorHandler = handler;
        return this;
    }
    /**
     * Defines decryption function that decrypts message attributes after consensus is reached.
     * Decryption function must accept a byte array of encrypted message and an Timestamp that is its consensus timestamp,
     *
     * @param decrypter The decrypter to use.
     * @return This transaction instance.
     */
    onDecrypt(decrypter) {
        this.decrypter = decrypter;
        return this;
    }
    /**
     * Defines a function that signs the message.
     *
     * @param signer The signing function to set.
     * @return This transaction instance.
     */
    signMessage(signer) {
        this.signer = signer;
        return this;
    }
    /**
     * Sets {@link TopicMessageSubmitTransaction} parameters, builds and signs it without executing it.
     * Topic ID and transaction message content are already set in the incoming transaction.
     *
     * @param builderFunction The transaction builder function.
     * @return This transaction instance.
     */
    buildAndSignTransaction(builderFunction) {
        this.buildTransactionFunction = builderFunction;
        return this;
    }
    /**
     * Builds the message and submits it to appnet's topic.
     *
     * @param client The hedera network client.
     * @return Transaction ID.
     */
    execute(client) {
        return __awaiter(this, void 0, void 0, function* () {
            new validator_1.Validator().checkValidationErrors('MessageTransaction execution failed: ', v => {
                return this.validate(v);
            });
            const envelope = !this.message ? this.buildMessage() : this.message;
            if (this.encrypter) {
                envelope.encrypt(this.provideMessageEncrypter(this.encrypter));
            }
            const messageContent = !envelope.getSignature() ? envelope.sign(this.signer) : arrays_utils_1.ArraysUtils.fromString(envelope.toJSON());
            if (this.receiver) {
                this.listener = this.provideTopicListener(this.topicId);
                this.listener.setStartTime(sdk_1.Timestamp.fromDate((0, moment_1.default)().subtract(MessageTransaction.SUBTRACT_TIME, 'seconds').toDate()))
                    .setIgnoreErrors(false)
                    .addFilter((response) => {
                    return arrays_utils_1.ArraysUtils.equals(messageContent, response.contents);
                })
                    .onError(err => {
                    return this.handleError(err);
                })
                    .onInvalidMessageReceived((response, reason) => {
                    if (!arrays_utils_1.ArraysUtils.equals(messageContent, response.contents)) {
                        return;
                    }
                    this.handleError(new Error(reason + ': ' + arrays_utils_1.ArraysUtils.toString(response.contents)));
                    this.listener.unsubscribe();
                })
                    .onDecrypt(this.decrypter)
                    .subscribe(client, msg => {
                    this.listener.unsubscribe();
                    this.receiver(msg);
                });
            }
            const tx = new sdk_1.TopicMessageSubmitTransaction().setTopicId(this.topicId).setMessage(messageContent);
            let transactionId;
            try {
                const response = yield this.buildTransactionFunction(tx).execute(client);
                transactionId = response.transactionId;
                this.executed = true;
            }
            catch (e) {
                this.handleError(e);
                if (this.listener) {
                    this.listener.unsubscribe();
                }
            }
            return transactionId;
        });
    }
    /**
     * Runs validation logic.
     *
     * @param validator The errors validator.
     */
    validate(validator) {
        validator.require(!this.executed, 'This transaction has already been executed.');
        validator.require(!!this.signer || (!!this.message && !!this.message.getSignature()), 'Signing function is missing.');
        validator.require(!!this.buildTransactionFunction, 'Transaction builder is missing.');
        validator.require((!!this.encrypter && !!this.decrypter) || (!this.decrypter && !this.encrypter), 'Either both encrypter and decrypter must be specified or none.');
    }
}
exports.MessageTransaction = MessageTransaction;
MessageTransaction.SUBTRACT_TIME = 1; // seconds
